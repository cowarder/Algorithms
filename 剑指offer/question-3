#include<iostream>
#include<vector>
using namespace std;

/*
  题目描述：在一个长度为n的数组中，所有的数字都是在0~n-1范围
  数组中有些数字是重复的，但是不知道哪些(但是至少有一个)，也
  不知道重复多少次找出任意一个重复的数字
*/
class FinDupNum1 {
	//将每一个值放到与其下标相同的位置
public:
	void find(vector<int> &nums){
		if (nums.size() == 0)
			return;
		else {
			for (int i = 0; i < nums.size(); i++) {
				while (nums[i]!=i) {
					if (nums[i] == nums[nums[i]]) {
						cout << nums[i] << endl;
						return;
					}
					int t = nums[i];
					nums[i] = nums[t];
					nums[t] = t;
						
				}
			}
		}
	}
};

/*
	在一个长度为n+1的整数数组中，所有的数字都在1~n之间
	所以在数组中至少有一个数是重复的，找出其中一个，但
	不能修改原先的数组
*/
class FinDupNum2 {
public:
	//解决方案1：时间优先策略
	void find1(vector<int>&nums) {
		vector<int>t;
		t.resize(nums.size() -1);
		for (int i = 0; i != nums.size(); i++)
			t[nums[i]-1] += 1;
		for (int i = 0; i != t.size(); i++)
			if (t[i] >1)
				cout << i + 1 << endl;
	}

	bool calNum(int lo, int hi, vector<int>&subNums) {
		cout << lo<<"  " << hi<<"   ";
		int sum = 0;
		for (int i = 0; i < subNums.size(); i++) 
			if ((subNums[i] >=lo)&&(subNums[i] <= hi))
				sum++;
		if (sum > (hi - lo + 1)) {
			cout << "true" << endl;
			return true;
		}
			
		else {
			cout << "false" << endl;
			return false;
		}
			
	}

	//解决方案2：空间优先策略
	void find2(int lo, int hi, vector<int>&nums) {
		if (lo == hi) {
			cout << lo << endl;
			return;
		}
		//cout << lo<<"    "<<hi << endl;
		int mid = lo + (hi-lo)/ 2;
		//cout << mid << endl;
		if (calNum(lo, mid, nums))
			find2(lo, mid,nums);
		if (calNum(mid + 1, hi, nums))
			find2(mid + 1, hi, nums);
	}
};

int main() {
	FinDupNum2 s;
	vector<int>v = { 2,3,5,4,3,2,6,7 };
	s.find2(1,v.size()-1,v);
	return 0;


}