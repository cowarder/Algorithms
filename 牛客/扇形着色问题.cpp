将一个圆形分成n个扇形，现有m种涂料，现在用这m种涂料对扇形进行着色，要求相邻两个扇形的颜色不能相同

思路：
	第一个m种可能，第二个m-1种可能，，，第n个m-1种可能，所以一共就是m(m-1)^(n-1)，但是由于第n个可能跟
	第一个进行重合，所以就需要减去这种情况，可以视作是第n个与第一个构成一个扇区进行着色，所以就是A(n-1,m)
	所以A(n,m)=m*(m-1)^(n-1)+A(n-1,m)

编程：
	int count(n,m){
		if(n==0||m==0)
			return 0;
		if(n==1)
			return m;
		vector<int>v;
		v.resize(n+1);
		v[1]=m;
		v[2]=m*(m-1);
		for(int i=3;i<=n;i++)
			v[i]=int(m*pow(m-1,i-1)-v[i-1]);
		cout<<v[n]<<endl;
	}