#include<iostream>
#include<vector>
using namespace std;

/*
	对于奇数n=2k+1：它的拆分的第一项一定是1，考虑去掉这个1，其实就一一对应于 2k的拆分，因此f(2k+1)=f(2k). 
	对于偶数n=2k：考虑有1和没有1的拆分。有1的拆分，与(2k-1)的拆分一一对应，面奇数的情况理由相同；
	没有1的拆分，将每项除以2，正好一一对应于k的所有拆分。因此f(2k)=f(2k-1)+f(k). 
	需要注意f(n)会很大，不要溢出了。最终结果只要求除以十亿的余数，在int的表示范围内， 因此不需要大数运算。
	注意余数的性质：(a+b)%m == (a%m+b%m)%m，所以只要对每个中间 结果也都取余数，就不会有溢出的问题，且不改变最终输出结果。
*/

int main() {
	vector<int> v;
	v.resize(1000001);
	v[1] = 1;
	for (int i = 2; i <= 1000000; i++) {
		if (i % 2 == 0)
			v[i] = (v[i - 1] + v[i / 2]) % 1000000000;
		else
			v[i] = v[i - 1] % 1000000000;
	}
	int num;

	while (cin>>num) {
		cout << v[num] << endl;
	}
	return 0;
}